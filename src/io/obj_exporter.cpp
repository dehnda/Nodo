#include "nodeflux/io/obj_exporter.hpp"
#include <fstream>
#include <iomanip>
#include <sstream>

namespace nodeflux::io {

bool ObjExporter::export_mesh(const core::Mesh &mesh,
                              const std::string &filename) {
  auto obj_content = mesh_to_obj_string(mesh);
  if (!obj_content) {
    return false;
  }

  return write_to_file(*obj_content, filename);
}

std::optional<std::string>
ObjExporter::mesh_to_obj_string(const core::Mesh &mesh) {
  if (mesh.empty()) {
    return std::nullopt;
  }

  constexpr int precision = 6; // Precision for floating point output
  std::ostringstream obj_stream;
  obj_stream << std::fixed << std::setprecision(precision);

  // Write header
  obj_stream << "# OBJ file generated by NodeFluxEngine\n";
  obj_stream << "# Vertices: " << mesh.vertex_count() << "\n";
  obj_stream << "# Faces: " << mesh.face_count() << "\n\n";

  // Write vertices
  const auto &vertices = mesh.vertices();
  for (int i = 0; i < vertices.rows(); ++i) {
    obj_stream << "v " << vertices(i, 0) << " " << vertices(i, 1) << " "
               << vertices(i, 2) << "\n";
  }

  obj_stream << "\n";

  // Write faces (OBJ uses 1-based indexing)
  const auto &faces = mesh.faces();
  for (int i = 0; i < faces.rows(); ++i) {
    obj_stream << "f " << (faces(i, 0) + 1) << " " << (faces(i, 1) + 1) << " "
               << (faces(i, 2) + 1) << "\n";
  }

  return obj_stream.str();
}

bool ObjExporter::write_to_file(const std::string &content,
                                const std::string &filename) {
  std::ofstream file(filename);
  if (!file.is_open()) {
    return false;
  }

  file << content;
  file.close();

  return file.good();
}

} // namespace nodeflux::io
