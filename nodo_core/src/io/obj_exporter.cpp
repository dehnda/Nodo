#include "nodo/io/obj_exporter.hpp"
#include "nodo/core/attribute_types.hpp"
#include <fstream>
#include <iomanip>
#include <sstream>

namespace nodo::io {

bool ObjExporter::export_geometry(const core::GeometryContainer &geometry,
                                  const std::string &filename) {
  auto obj_content = geometry_to_obj_string(geometry);
  if (!obj_content) {
    return false;
  }

  return write_to_file(*obj_content, filename);
}

std::optional<std::string>
ObjExporter::geometry_to_obj_string(const core::GeometryContainer &geometry) {
  if (geometry.point_count() == 0) {
    return std::nullopt;
  }

  // Get position attribute (required)
  const auto *positions =
      geometry.get_point_attribute_typed<core::Vec3f>(core::standard_attrs::P);
  if (positions == nullptr) {
    return std::nullopt;
  }

  constexpr int precision = 6; // Precision for floating point output
  std::ostringstream obj_stream;
  obj_stream << std::fixed << std::setprecision(precision);

  // Write header
  obj_stream << "# OBJ file generated by NodeFluxEngine\n";
  obj_stream << "# Points: " << geometry.point_count() << "\n";
  obj_stream << "# Primitives: " << geometry.primitive_count() << "\n\n";

  // Write vertex positions
  const auto &pos_values = positions->values();
  for (const auto &pos : pos_values) {
    obj_stream << "v " << pos.x() << " " << pos.y() << " " << pos.z() << "\n";
  }

  obj_stream << "\n";

  // Write UV texture coordinates if available (vertex attribute)
  const auto *uvs = geometry.get_vertex_attribute_typed<Eigen::Vector2f>(
      core::standard_attrs::uv);
  if (uvs != nullptr) {
    const auto &uv_values = uvs->values();
    for (const auto &uv_coord : uv_values) {
      // OBJ uses vt for texture coordinates (u, v)
      obj_stream << "vt " << uv_coord.x() << " " << uv_coord.y() << "\n";
    }
    obj_stream << "\n";
  }

  // Write vertex normals if available
  const auto *normals =
      geometry.get_point_attribute_typed<core::Vec3f>(core::standard_attrs::N);
  if (normals != nullptr) {
    const auto &normal_values = normals->values();
    for (const auto &normal : normal_values) {
      obj_stream << "vn " << normal.x() << " " << normal.y() << " "
                 << normal.z() << "\n";
    }
    obj_stream << "\n";
  }

  // Write faces (primitives)
  // OBJ uses 1-based indexing
  const auto &topology = geometry.topology();
  for (size_t prim_idx = 0; prim_idx < topology.primitive_count(); ++prim_idx) {
    const auto &prim_verts = topology.get_primitive_vertices(prim_idx);

    if (prim_verts.size() < 3) {
      continue; // Skip degenerate primitives
    }

    obj_stream << "f";
    for (int vert_idx : prim_verts) {
      int point_idx = topology.get_vertex_point(vert_idx);
      // OBJ format: vertex_index/texture_index/normal_index (1-based)
      obj_stream << " " << (point_idx + 1);

      if (uvs != nullptr || normals != nullptr) {
        obj_stream << "/";
        if (uvs != nullptr) {
          obj_stream << (vert_idx + 1); // UV is per-vertex
        }
        if (normals != nullptr) {
          obj_stream << "/" << (point_idx + 1);
        }
      }
    }
    obj_stream << "\n";
  }

  return obj_stream.str();
}

bool ObjExporter::write_to_file(const std::string &content,
                                const std::string &filename) {
  std::ofstream file(filename);
  if (!file.is_open()) {
    return false;
  }

  file << content;
  file.close();

  return file.good();
}

} // namespace nodo::io
