# M3.3: Complete Expression System for Parameters

## Overview
Extend M3.2's basic graph parameter references to a full expression system supporting numeric parameters, parameter-to-parameter references, and mathematical expressions.

## Current State (M3.2)

### What Works ✅
- Graph parameters (Int, Float, String, Bool, Vector3) can be created/edited/deleted
- String/Code parameters can reference graph parameters using `$param_name` syntax
- Expressions are resolved at execution time via ParameterExpressionResolver
- Serialization preserves graph parameters

### Limitations ❌
- Numeric widgets (Int, Float, Vector3) use spinboxes - can't type expressions
- No parameter-to-parameter references (like Houdini's relative paths)
- No mathematical expressions (e.g., `$radius * 2 + 1`)
- No visual indication of which fields contain expressions
- No auto-complete for parameter names
- No expression validation or error reporting

## M3.3 Goals: Expression System

### 1. Expression Mode for Numeric Parameters

#### Feature: Dual-Mode Input
**Problem**: Spinboxes only accept numeric values, not expressions.

**Solution**: Add toggle between numeric and expression modes:

```
┌─────────────────────────────────────┐
│ Radius          [≡] [1.500] [──●──] │  ← Numeric mode (default)
└─────────────────────────────────────┘

┌─────────────────────────────────────┐
│ Radius          [#] [$base_radius ] │  ← Expression mode
└─────────────────────────────────────┘
```

**UI Design**:
- Toggle button with icons: `[≡]` (numeric) ↔ `[#]` (expression)
- Click to switch modes
- Expression mode shows text field instead of spinbox
- Display resolved value as tooltip or inline preview

**Implementation**:
```cpp
// FloatWidget.h additions
void setExpressionMode(bool enabled);
bool isExpressionMode() const;
QString getExpression() const;
void setExpression(const QString &expr);

// Store both:
float numeric_value_;        // For numeric mode
QString expression_text_;    // For expression mode
bool is_expression_mode_;
```

**Serialization**:
```json
{
  "name": "radius",
  "type": "Float",
  "value": 1.5,
  "expression": "$base_radius * 2",
  "is_expression": true
}
```

### 2. Parameter-to-Parameter References

#### Feature: Houdini-Style Parameter Paths

**Problem**: Can't reference other node parameters, only graph parameters.

**Use Cases**:
- Copy Transform node's translate values to another Transform
- Link multiple nodes to share parameter values
- Create parameter hierarchies and dependencies

**Syntax**:
```
$param_name              → Graph parameter
../node1/param_name      → Relative node parameter
/obj/node1/param_name    → Absolute node parameter
ch("../node1/param")     → Houdini-style function
```

**Examples**:
```
Transform Node 1:
  translate_x = 5.0

Transform Node 2:
  translate_x = "ch(\"../transform1/translate_x\") + 1.0"
  → Resolves to 6.0
```

**Implementation Strategy**:
1. Extend ParameterExpressionResolver to handle relative paths
2. Add node tree traversal: `../` (parent), `/` (root)
3. Parameter lookup by path: `node_graph->resolve_parameter_path(path)`
4. Cache resolved paths for performance

### 3. Mathematical Expression Evaluation

#### Feature: Expression Parser & Evaluator

**Problem**: Can only do simple substitution, not math.

**Solution**: Integrate expression parser (exprtk already in dependencies!)

**Supported Operations**:
```
Arithmetic: +, -, *, /, %
Functions: sin, cos, tan, sqrt, pow, abs, min, max
Logic: <, >, ==, !=, &&, ||
Ternary: condition ? true_val : false_val
```

**Examples**:
```
$radius * 2                           → Simple math
$radius * sin($frame * 0.1)           → Trigonometry
$count < 10 ? $count : 10             → Conditional
ch("../box1/width") + $padding * 2    → Mixed references
```

**Implementation**:
```cpp
class ExpressionEvaluator {
public:
  std::optional<double> evaluate(const std::string& expr,
                                 const NodeGraph& graph,
                                 const GraphNode* current_node);
private:
  exprtk::parser<double> parser_;
  std::unordered_map<std::string, double> variables_;
};
```

### 4. Visual Expression Indicators

#### Feature: Show Which Fields Have Expressions

**Problem**: No way to tell if a field contains an expression.

**Solutions**:

**A) Icon Indicator**:
```
┌─────────────────────────────────────┐
│ Radius       [fx] [──────────] ●    │  ← Expression present
└─────────────────────────────────────┘
```

**B) Color Coding**:
```
┌─────────────────────────────────────┐
│ Radius          [1.500]             │  ← Normal (gray)
│ Subdivs      [fx] $detail           │  ← Expression (blue)
│ Scale        [!] $missing           │  ← Error (red)
└─────────────────────────────────────┘
```

**C) Tooltip Preview**:
```
Hover over [fx]:
┌─────────────────────────┐
│ Expression:             │
│ $base_radius * 2        │
│                         │
│ Resolves to: 3.000      │
└─────────────────────────┘
```

**Implementation**:
- Add icon label to BaseParameterWidget
- Update icon based on expression state
- Show resolved value in tooltip

### 5. Expression Auto-Complete

#### Feature: Parameter Name Suggestions

**Problem**: Hard to remember parameter names, prone to typos.

**Solution**: Dropdown with available parameters when typing `$` or `ch(`

```
User types: $ba
┌─────────────────────────────────────┐
│ Radius          [$ba|              ]│
│                  ┌──────────────────┤
│                  │ $base_radius     │
│                  │ $base_size       │
│                  │ $background      │
│                  └──────────────────┤
└─────────────────────────────────────┘
```

**Implementation**:
```cpp
class ExpressionCompleter : public QCompleter {
public:
  void setNodeGraph(const NodeGraph* graph);
  void setCurrentNode(const GraphNode* node);

  QStringList getCompletions(const QString& prefix);

private:
  std::vector<std::string> graph_params_;
  std::vector<std::string> node_params_;
};
```

**Trigger**:
- User types `$` → Show graph parameters
- User types `../` → Show sibling nodes
- User types `ch("` → Show all available parameters

### 6. Expression Validation & Error Reporting

#### Feature: Real-time Expression Checking

**Problem**: Invalid expressions fail silently at execution time.

**Solution**: Validate expressions as user types.

**Validation Checks**:
1. **Syntax**: Valid expression structure
2. **References**: Parameter exists
3. **Type**: Compatible types (can't assign string to float)
4. **Cycles**: No circular dependencies

**UI Feedback**:
```
┌─────────────────────────────────────┐
│ Radius       [!] [$nonexistent    ] │
│              └─ Parameter not found │
└─────────────────────────────────────┘

┌─────────────────────────────────────┐
│ Scale        [!] [$radius / 0     ] │
│              └─ Division by zero    │
└─────────────────────────────────────┘
```

**Implementation**:
```cpp
struct ValidationResult {
  bool is_valid;
  std::string error_message;
  std::vector<std::string> missing_params;
};

class ExpressionValidator {
public:
  ValidationResult validate(const std::string& expr,
                           const NodeGraph& graph,
                           const GraphNode* node);
};
```

## Implementation Plan

### Phase 1: Numeric Expression Mode (1-2 days)
- [ ] Add expression mode toggle to FloatWidget
- [ ] Add expression mode to IntWidget
- [ ] Add expression mode to Vector3Widget
- [ ] Update PropertyPanel to handle expression mode
- [ ] Serialize expression vs numeric value
- [ ] Test with graph parameters

### Phase 2: Math Expression Evaluator (1 day)
- [ ] Integrate exprtk parser
- [ ] Create ExpressionEvaluator class
- [ ] Support arithmetic operators
- [ ] Support mathematical functions (sin, cos, sqrt, etc.)
- [ ] Add unit tests for expression evaluation

### Phase 3: Node Parameter References (2 days)
- [ ] Implement parameter path resolution (`../node/param`)
- [ ] Add ch() function support
- [ ] Handle relative vs absolute paths
- [ ] Add node tree traversal
- [ ] Test parameter dependencies

### Phase 4: Visual Indicators (1 day)
- [ ] Add expression icon to BaseParameterWidget
- [ ] Color-code expression fields
- [ ] Show resolved value in tooltip
- [ ] Update icon on expression changes

### Phase 5: Auto-Complete (2 days)
- [ ] Create ExpressionCompleter class
- [ ] Trigger on `$`, `../`, `ch(`
- [ ] Show graph parameters
- [ ] Show node parameters
- [ ] Fuzzy matching for filtering

### Phase 6: Validation & Error Reporting (1 day)
- [ ] Create ExpressionValidator class
- [ ] Check syntax errors
- [ ] Check missing parameters
- [ ] Check circular dependencies
- [ ] Display error messages inline

### Phase 7: Testing & Documentation (1 day)
- [ ] Create test graphs with complex expressions
- [ ] Test parameter dependencies
- [ ] Test circular dependency detection
- [ ] Write user documentation
- [ ] Create tutorial examples

**Total Estimated Time**: 9-11 days

## Technical Architecture

### Expression Resolution Flow

```
User Input: "$base_radius * 2"
     ↓
ExpressionValidator
  - Check syntax ✓
  - Check references ✓
  - Check types ✓
     ↓
Store Expression
  - NodeParameter stores expression string
  - Mark as expression mode
     ↓
Execution Time
     ↓
ParameterExpressionResolver
  - Resolve $base_radius → 1.5
  - Replace in expression → "1.5 * 2"
     ↓
ExpressionEvaluator (exprtk)
  - Parse expression
  - Evaluate → 3.0
     ↓
Pass to SOP Node
  - node->set_parameter("radius", 3.0f)
```

### Data Model Changes

```cpp
// node_parameter.hpp
struct NodeParameter {
  std::string name;
  Type type;

  // Value storage
  union {
    float float_value;
    int int_value;
    bool bool_value;
    // ...
  };

  // NEW: Expression support
  std::string expression;      // Expression string if in expression mode
  bool is_expression = false;  // Whether to use expression or value
  bool is_valid = true;        // Validation state
  std::string error_message;   // Validation error if any
};
```

## Examples & Use Cases

### Example 1: Parametric Architecture
```
Graph Parameters:
  building_height = 100
  floor_count = 10

Box Node:
  height = "$building_height"

Array Node:
  count = "$floor_count"
  translate_y = "$building_height / $floor_count"
```

### Example 2: Linked Transforms
```
Transform Node "controller":
  rotate_y = 45.0

Transform Node "follower":
  rotate_y = "ch(\"../controller/rotate_y\") * 2"
  → Auto-updates when controller rotates
```

### Example 3: Conditional Logic
```
Graph Parameters:
  use_high_detail = true

Subdivide Node:
  subdivisions = "$use_high_detail ? 4 : 1"
  → 4 subdivisions if true, 1 if false
```

## Dependencies

### Existing
- ✅ exprtk (already in dependencies) - Expression parser
- ✅ ParameterExpressionResolver - Basic substitution
- ✅ NodeParameter - Parameter storage

### New Requirements
- QCompleter integration for auto-complete
- Syntax highlighting for expression fields (optional)
- Expression debugger UI (future enhancement)

## Comparison with Other Tools

### Houdini
**Similarities**:
- ch() function for parameter references
- Relative paths (../node/param)
- Mathematical expressions
- Expression button/toggle

**Differences**:
- Houdini uses $ for environment vars, ch() for parameters
- We use $ for both (simpler for users)
- Houdini has expression language (HScript), we use math only

### Blender Geometry Nodes
**Similarities**:
- Input parameters flow through nodes
- Node groups can expose parameters

**Differences**:
- Blender uses node connections, not text expressions
- We support both approaches (expressions + connections)

### Grasshopper/Dynamo
**Similarities**:
- Visual programming with parameters
- Math expression evaluation

**Differences**:
- They use visual expression nodes
- We use inline text expressions (faster for power users)

## Future Enhancements (M3.4+)

### Animation/Keyframes
- Time-based expressions: `$frame * 0.1`
- Keyframe interpolation
- Animation curves

### Expression Libraries
- User-defined functions
- Expression presets
- Shared expression snippets

### Visual Expression Editor
- Node-based expression builder
- Visual function builder
- Expression debugger with step-through

### Performance Optimization
- Expression caching
- Lazy evaluation
- Parallel expression evaluation

## Success Criteria

M3.3 is complete when:
- [ ] All numeric parameters support expression mode
- [ ] Mathematical expressions evaluate correctly
- [ ] Node parameter references work (ch() function)
- [ ] Visual indicators show expression state
- [ ] Auto-complete suggests parameter names
- [ ] Validation catches errors before execution
- [ ] Test graphs demonstrate all features
- [ ] User documentation is complete
- [ ] No regressions in M3.2 functionality

## Migration from M3.2

Existing graphs with M3.2 string-based expressions:
- ✅ Continue to work (backward compatible)
- ✅ String parameters keep using simple substitution
- ✅ New expression system is opt-in (toggle button)
- ✅ Can migrate parameters to expression mode as needed
