# M1.2 UI Widget Library - Usage Guide

## Overview

This document describes the reusable Qt parameter widgets created for the Nodo Studio property panel. All widgets follow a consistent design pattern with VS Code dark theme styling and advanced UX features like value scrubbing.

## Widget Architecture

All parameter widgets inherit from `BaseParameterWidget` which provides:
- Consistent label and tooltip display
- VS Code dark theme colors (#1e1e1e background, #007acc accent)
- Horizontal layout with label on left, control on right
- Virtual `createControlWidget()` for customization

## Available Widgets

### 1. FloatWidget
**Purpose**: Editing floating-point numeric parameters

**Features**:
- QDoubleSpinBox for precise value entry
- Optional horizontal slider for visual feedback
- Value scrubbing: Click-drag on label to adjust value
  - Shift: Fine adjustment (0.01x sensitivity)
  - Ctrl: Coarse adjustment (10x sensitivity)
  - Alt: Snap to 0.1 increments
- Cursor wraps to prevent leaving screen during scrub
- Cursor hidden during scrubbing for clean UX

**Usage**:
```cpp
auto *widget = new FloatWidget("Radius", 1.0, 0.0, 10.0, "Sphere radius");
widget->setSliderVisible(true);
widget->setValueChangedCallback([](double value) {
    // Handle value change
});
```

### 2. IntWidget
**Purpose**: Editing integer numeric parameters

**Features**:
- QSpinBox for integer values
- Optional horizontal slider
- Value scrubbing with modifiers:
  - Shift: Fine (1 unit per 10 pixels)
  - Ctrl: Coarse (10 units per pixel)
  - Alt: Snap to multiples of 5
  - Normal: 1 unit per pixel

**Usage**:
```cpp
auto *widget = new IntWidget("Divisions", 10, 1, 100, "Number of subdivisions");
widget->setSliderVisible(true);
```

### 3. Vector3Widget
**Purpose**: Editing 3D vector parameters (X, Y, Z)

**Features**:
- Three separate QDoubleSpinBox controls for X, Y, Z
- Color-coded component labels (Red, Green, Blue)
- Per-component value scrubbing on each label
- Uniform editing mode (lock icon) to sync all components
- Independent range support per component

**Usage**:
```cpp
auto *widget = new Vector3Widget("Position", 0.0, 0.0, 0.0, -100.0, 100.0, "3D position");
widget->setUniformEnabled(true); // Lock all components together
widget->setValueChangedCallback([](double x, double y, double z) {
    // Handle vector change
});
```

### 4. ModeSelectorWidget
**Purpose**: Selecting from multiple mutually exclusive options

**Features**:
- Segmented button group (toggle buttons)
- Horizontal layout with no spacing for unified look
- Rounded corners on left/right ends
- Active state with accent color highlight
- Commonly used for operation types, coordinate systems

**Usage**:
```cpp
std::vector<QString> options = {"Add", "Subtract", "Multiply"};
auto *widget = new ModeSelectorWidget("Operation", options, 0, "Boolean operation type");
widget->setSelectionChangedCallback([](int index, const QString &option) {
    // Handle selection
});
```

### 5. CheckboxWidget
**Purpose**: Boolean true/false parameters

**Features**:
- Standard QCheckBox with custom styling
- 16x16 pixel checkbox indicator
- Hover and checked states with accent color

**Usage**:
```cpp
auto *widget = new CheckboxWidget("Enable Modifier", false, "Toggle modifier on/off");
widget->setValueChangedCallback([](bool checked) {
    // Handle checkbox change
});
```

### 6. DropdownWidget
**Purpose**: Selecting from a list of options (dropdown)

**Features**:
- QComboBox with custom styling
- Scrollable dropdown for many options
- Accent color on selection
- Alternative to ModeSelectorWidget for longer lists

**Usage**:
```cpp
std::vector<QString> options = {"Option A", "Option B", "Option C"};
auto *widget = new DropdownWidget("Mode", options, 0, "Select operation mode");
widget->setSelectionChangedCallback([](int index, const QString &option) {
    // Handle selection
});
```

### 7. TextWidget
**Purpose**: Single-line text/string input

**Features**:
- QLineEdit with placeholder support
- Two callbacks: textChanged (every keystroke) and editingFinished (on Enter/focus loss)
- Selection highlighting with accent color

**Usage**:
```cpp
auto *widget = new TextWidget("Name", "default_name", "Enter name...", "Object name");
widget->setTextChangedCallback([](const QString &text) {
    // Handle text change (every keystroke)
});
widget->setTextEditingFinishedCallback([](const QString &text) {
    // Handle editing finished (Enter pressed or focus lost)
});
```

### 8. SliderWidget
**Purpose**: Numeric parameters using slider control

**Features**:
- QSlider with 1000-step internal resolution
- Value label showing current value (formatted to 3 decimal places)
- Optional value suffix (e.g., "%" or "Â°")
- Useful for normalized ranges (0-1) or percentages

**Usage**:
```cpp
auto *widget = new SliderWidget("Opacity", 1.0, 0.0, 1.0, "Material opacity");
widget->setValueSuffix("%");
widget->setValueChangedCallback([](double value) {
    // Handle slider change
});
```

### 9. ColorWidget
**Purpose**: RGB/RGBA color parameters

**Features**:
- Color swatch button showing current color
- Opens QColorDialog on click
- Optional alpha channel editing
- Button displays hex color code
- Text color adjusts for contrast (black/white based on lightness)

**Usage**:
```cpp
auto *widget = new ColorWidget("Color", QColor(255, 0, 0), false, "Material color");
widget->setEnableAlpha(true); // Enable alpha channel
widget->setColorChangedCallback([](const QColor &color) {
    // Handle color change
});
```

### 10. FilePathWidget
**Purpose**: File/directory path selection

**Features**:
- QLineEdit for path display/manual entry
- Browse button (ðŸ“) to open file dialog
- Three modes: OpenFile, SaveFile, Directory
- File filter support (e.g., "Images (*.png *.jpg)")
- Starts browser in current file's directory

**Usage**:
```cpp
auto *widget = new FilePathWidget("Texture", "", FilePathWidget::Mode::OpenFile,
                                   "Images (*.png *.jpg *.bmp);;All Files (*)",
                                   "Select texture image");
widget->setPathChangedCallback([](const QString &path) {
    // Handle path change
});
```

## VS Code Dark Theme Colors

All widgets use these consistent color constants from `BaseParameterWidget.h`:

```cpp
const char* COLOR_BACKGROUND = "#1e1e1e";      // Main background
const char* COLOR_PANEL = "#252526";           // Panel background
const char* COLOR_INPUT_BG = "#3c3c3c";        // Input field background
const char* COLOR_INPUT_BORDER = "#555555";    // Border color
const char* COLOR_ACCENT = "#007acc";          // Accent/highlight color
const char* COLOR_TEXT_PRIMARY = "#e0e0e0";    // Primary text
const char* COLOR_TEXT_SECONDARY = "#9b9b9b";  // Secondary text
```

## Value Scrubbing

Value scrubbing is a powerful UX feature implemented in FloatWidget, IntWidget, and Vector3Widget:

1. **Click-drag on label** to adjust value by mouse movement
2. **Modifier keys** change sensitivity:
   - **Shift**: Fine adjustment (0.01x or 1/10 of normal)
   - **Ctrl**: Coarse adjustment (10x faster)
   - **Alt**: Snap to grid (0.1 for floats, 5 for ints)
3. **Cursor behavior**:
   - Hidden during scrubbing (replaced with blank cursor)
   - Wraps back to start position after ~200 pixels to prevent leaving screen
   - Restored to normal when mouse released

## Integration with PropertyPanel

To use these widgets in the PropertyPanel:

```cpp
#include "widgets/FloatWidget.h"
#include "widgets/Vector3Widget.h"
// ... other widgets

void PropertyPanel::buildParameterUI(const Parameter &param) {
    switch (param.type) {
        case ParameterType::Float: {
            auto *widget = new FloatWidget(
                param.label,
                param.getValue<double>(),
                param.min,
                param.max,
                param.description,
                this
            );
            widget->setValueChangedCallback([this, &param](double value) {
                // Update parameter in backend
                param.setValue(value);
                // Trigger node re-cook
                emit parameterChanged(param.name);
            });
            layout->addWidget(widget);
            break;
        }
        // ... handle other types
    }
}
```

## Next Steps (Remaining M1.2 Tasks)

1. **Universal Section Styling**: Create collapsible parameter sections with gray headers
2. **PropertyPanel Integration**: Connect widgets to backend parameter system
3. **Testing**: Create test UI to verify all widgets work correctly
4. **Documentation**: Add screenshots and video demonstrations
5. **Polish**: Fine-tune spacing, sizing, and responsive behavior

## Notes

- All widgets support callback-based and signal-based notification patterns
- Widgets are designed to be decoupled from backend (can be used standalone)
- The base class pattern makes it easy to add new widget types
- Qt's MOC (Meta-Object Compiler) automatically processes Q_OBJECT macros
- Icon resources (check.svg, chevron-down.svg) referenced in some widgets need to be added to resources.qrc
